<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>トーナメント管理</title>
    <link rel="icon" href="../icons/favicon.ico">

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Kosugi+Maru&family=Zen+Kaku+Gothic+New:wght@500;700;900&display=swap"
        rel="stylesheet">
    <link
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200"
        rel="stylesheet" />

    <style>
        /* --- テーマ定義 --- */
        :root {
            --color-main: #1F2937;
            --color-bg: #F3F4F6;
            --color-panel: #FFFFFF;
            --color-shadow: #D1D5DB;
            --color-warning-bg: #FEF08A;
            --color-warning-text: #854D0E;
            --color-live-bg: #EF4444;
            --color-live-text: #FFFFFF;
            --color-live-inactive: #9CA3AF;
            
            /* Match Colors */
            --color-alpha: #d0be08;
            --color-bravo: #3a0ccd;
            --color-win-bg: #FEF3C7;
        }

        body {
            font-family: 'Zen Kaku Gothic New', 'Kosugi Maru', sans-serif;
            background-color: var(--color-bg);
            color: var(--color-main);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding-top: 1rem;
        }

        /* --- メインエリア --- */
        .main-container {
            flex: 1;
            padding: 0 1rem 1.5rem 1rem;
            width: 100%;
            max-width: 100%;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            overflow: hidden;
        }

        /* --- コントロールパネル --- */
        .control-panel {
            background-color: var(--color-panel);
            border: 2px solid var(--color-main);
            border-radius: 0.75rem;
            padding: 1rem 1.5rem;
            box-shadow: 4px 4px 0 0 var(--color-shadow);
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
            justify-content: space-between;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .format-select-wrapper {
            position: relative;
            display: inline-block;
        }
        .format-select {
            appearance: none;
            background-color: #FFFFFF;
            border: 2px solid var(--color-main);
            border-radius: 0.5rem;
            padding: 0.5rem 2.5rem 0.5rem 1rem;
            font-weight: 900;
            font-size: 1rem;
            color: var(--color-main);
            cursor: pointer;
            box-shadow: 2px 2px 0 0 var(--color-shadow);
            transition: all 0.2s;
        }
        .format-select:hover {
            transform: translate(-1px, -1px);
            box-shadow: 3px 3px 0 0 var(--color-shadow);
        }
        .format-select:focus {
            outline: none;
            box-shadow: 2px 2px 0 0 var(--color-main);
        }
        .select-arrow {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            color: var(--color-main);
        }

        /* --- トーナメント表エリア --- */
        .bracket-container {
            flex: 1;
            overflow: auto;
            padding: 1rem;
            border: 2px dashed #E5E7EB;
            border-radius: 0.75rem;
            background-color: rgba(255,255,255,0.5);
            scrollbar-width: thin;
            scrollbar-color: var(--color-main) transparent;
            cursor: grab;
            user-select: none;
        }
        .bracket-container.active { cursor: grabbing; }
        
        .bracket-wrapper {
            display: flex; gap: 4rem; min-width: max-content; padding-bottom: 2rem;
        }

        .round-column {
            display: flex; flex-direction: column; justify-content: space-around;
            gap: 1rem; width: 340px; flex-shrink: 0;
        }

        /* ラウンドタイトル */
        .round-header {
            position: sticky; top: 0;
            background: rgba(243, 244, 246, 0.95); backdrop-filter: blur(4px);
            z-index: 20;
            padding-bottom: 0.5rem; border-bottom: 2px dashed var(--color-shadow);
            margin-bottom: 1rem; text-align: center;
        }

        .round-name-input {
            font-family: inherit; font-weight: 900; font-size: 1.1rem;
            text-align: center; background: transparent;
            border: 2px solid transparent; border-radius: 0.25rem;
            color: var(--color-main); width: 100%; padding: 0.25rem;
            transition: all 0.2s; cursor: pointer;
        }
        .round-name-input:hover { background-color: rgba(255,255,255,0.5); border-color: #D1D5DB; }
        .round-name-input:focus { outline: none; background-color: #FFFFFF; border-color: var(--color-main); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }

        /* --- マッチカード --- */
        .match-card {
            background-color: #FFFFFF;
            border: 2px solid var(--color-main);
            border-radius: 0.5rem;
            box-shadow: 4px 4px 0 0 var(--color-shadow);
            padding: 0.75rem;
            display: flex; flex-direction: column; gap: 0.75rem;
            position: relative; transition: transform 0.2s;
            margin: 0.5rem 0;
        }
        .match-card:hover { z-index: 10; box-shadow: 6px 6px 0 0 var(--color-shadow); }

        /* 配信中カード強調 */
        .match-card.status-active {
            border-color: var(--color-live-bg);
            box-shadow: 4px 4px 0 0 rgba(239, 68, 68, 0.3);
        }
        .match-card.status-inactive {
            border-color: var(--color-live-inactive);
            box-shadow: 4px 4px 0 0 rgba(107, 114, 128, 0.3);
        }

        /* 配信ボタン/バッジエリア */
        .match-header {
            position: absolute; top: -12px; left: 0; width: 100%;
            display: flex; justify-content: space-between; padding: 0 0.5rem;
            pointer-events: none; opacity: 0; transition: opacity 0.2s;
        }
        .match-card:hover .match-header,
        .match-card.is-live .match-header { opacity: 1; }

        .header-left-group {
            display: flex; gap: 4px; pointer-events: auto;
        }

        .match-id {
            background: var(--color-main); color: white; font-size: 0.6rem;
            padding: 2px 6px; border-radius: 4px; font-weight: bold;
            z-index: 5;
        }

        .bo-badge {
            background: #E5E7EB; color: #4B5563; font-size: 0.6rem;
            padding: 2px 6px; border-radius: 4px; font-weight: bold;
            z-index: 5; border: 1px solid #D1D5DB;
        }

        .live-control { pointer-events: auto; z-index: 5; }

        .live-btn {
            background-color: #FFFFFF; border: 2px solid #D1D5DB;
            color: #D1D5DB; border-radius: 9999px; padding: 2px 8px;
            font-size: 0.6rem; font-weight: 900; cursor: pointer;
            display: flex; align-items: center; gap: 0.25rem;
            transition: all 0.2s;
        }
        .live-btn:hover {
            border-color: var(--color-live-bg); color: var(--color-live-bg);
            background-color: #FFF5F5;
        }

        /* ON AIR Styles */
        .match-card.status-active .live-btn {
            background-color: var(--color-live-bg); border-color: var(--color-live-bg);
            color: white; box-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
            animation: pulse-red 2s infinite;
        }
        .match-card.status-inactive .live-btn {
            background-color: var(--color-live-inactive); border-color: var(--color-live-inactive);
            color: white; box-shadow: none; animation: none;
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
            70% { box-shadow: 0 0 0 6px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }

        /* チーム行 */
        .team-row {
            display: flex; align-items: center; gap: 0.5rem; padding: 0.4rem;
            border-radius: 0.25rem; border: 2px solid transparent;
            background-color: #F9FAFB;
        }
        .team-row.winner { background-color: #FEF3C7; border-color: #F59E0B; font-weight: bold; }
        .team-row.loser { opacity: 0.5; background-color: #E5E7EB; }

        .team-label { width: 4px; height: 100%; min-height: 24px; border-radius: 2px; flex-shrink: 0; }
        .label-alpha { background-color: var(--color-alpha); }
        .label-bravo { background-color: var(--color-bravo); }

        .team-info-area { flex: 1; min-width: 0; display: flex; align-items: center; }
        .team-select {
            width: 100%; font-size: 0.85rem; font-weight: 700; padding: 0.25rem;
            border: 1px solid #E5E7EB; border-radius: 0.25rem; min-width: 12em; 
        }
        .team-name-display {
            width: 100%; font-size: 0.9rem; font-weight: 700; padding: 0.25rem;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; min-width: 12em; 
        }
        .text-undecided { color: #9CA3AF; font-weight: 500; }

        .action-area { display: flex; align-items: center; gap: 0.5rem; flex-shrink: 0; }
        .score-select {
            width: 44px; height: 32px; font-weight: 900; text-align: center;
            border: 1px solid #D1D5DB; border-radius: 0.25rem; background: #FFFFFF; cursor: pointer;
        }
        .win-badge {
            width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;
            border: 2px solid #E5E7EB; border-radius: 50%;
            color: #D1D5DB; background: #FFF; 
            cursor: default; pointer-events: none;
        }
        .win-badge.active { background: var(--color-main); color: #FFF; border-color: var(--color-main); }
        
        /* Connector */
        .match-card::after {
            content: '→'; position: absolute; right: -32px; top: 50%;
            transform: translateY(-50%); color: var(--color-shadow);
            font-weight: 900; font-size: 1.5rem; display: none;
        }
        .round-column:not(:last-child) .match-card::after { display: block; }

        /* Read-only */
        body.read-only-mode .control-panel { display: none !important; }
        body.read-only-mode .team-select, body.read-only-mode .score-select {
            pointer-events: none; background-color: transparent; border: none; appearance: none;
            color: var(--color-main); padding-left: 0;
        }
        body.read-only-mode .win-badge:not(.active) { opacity: 0.2; border-color: transparent; background: transparent; }
        body.read-only-mode .round-name-input { pointer-events: none; border-color: transparent; }
        body.read-only-mode .live-btn { pointer-events: none; }

        /* Reset Button */
        .reset-btn {
            display: flex; align-items: center; justify-content: center;
            width: 40px; height: 40px;
            border-radius: 0.5rem; border: 2px solid #EF4444;
            color: #EF4444; background-color: #FFFFFF;
            cursor: pointer; transition: all 0.2s;
        }
        .reset-btn:hover { background-color: #FEF2F2; transform: translate(-1px, -1px); box-shadow: 2px 2px 0 0 #FECACA; }
        .reset-btn:active { transform: translate(0, 0); box-shadow: none; }

        /* Modal */
        .modal-overlay {
            position: fixed; inset: 0; background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(4px); display: flex; align-items: center; justify-content: center;
            z-index: 100; opacity: 0; pointer-events: none; transition: opacity 0.2s;
        }
        .modal-overlay.show { opacity: 1; pointer-events: auto; }
        .modal-content {
            background: #FFFFFF; width: 90%; max-width: 400px;
            border: 2px solid var(--color-main); box-shadow: 8px 8px 0 var(--color-main);
            border-radius: 1rem; padding: 1.5rem;
            transform: translateY(20px); transition: transform 0.3s;
            display: flex; flex-direction: column; gap: 1rem;
        }
        .modal-overlay.show .modal-content { transform: translateY(0); }
        .modal-title { font-size: 1.1rem; font-weight: 900; color: var(--color-main); }
        .modal-body { font-size: 0.9rem; font-weight: 700; color: #4B5563; line-height: 1.6; }
        .modal-actions { display: flex; justify-content: flex-end; gap: 1rem; margin-top: 0.5rem; }
        .btn-modal {
            padding: 0.5rem 1.25rem; border-radius: 0.5rem; font-weight: 900; font-size: 0.85rem;
            cursor: pointer; transition: all 0.2s; border: 2px solid var(--color-main);
        }
        .btn-cancel { background: #FFF; color: var(--color-main); }
        .btn-cancel:hover { background: #F3F4F6; }
        .btn-confirm { background: var(--color-main); color: #FFF; box-shadow: 2px 2px 0 var(--color-shadow); }
        .btn-confirm:hover { transform: translate(-1px, -1px); box-shadow: 3px 3px 0 var(--color-shadow); }
        .btn-danger { background: #EF4444; color: #FFF; box-shadow: 2px 2px 0 var(--color-shadow); border-color: #EF4444; }
        .btn-danger:hover { background: #DC2626; }
    </style>
</head>

<body>

    <main class="main-container">
        <div class="control-panel">
            <div class="control-group">
                <span class="font-black text-gray-500 text-sm tracking-widest">TOURNAMENT SIZE</span>
                <div class="format-select-wrapper">
                    <select id="format-select" class="format-select">
                        <option value="4">4 TEAMS</option>
                        <option value="8">8 TEAMS</option>
                        <option value="16">16 TEAMS</option>
                        <option value="32">32 TEAMS</option>
                    </select>
                    <span class="material-symbols-rounded select-arrow">expand_more</span>
                </div>
            </div>
            <div class="flex items-center gap-4">
                <div class="text-xs font-bold text-gray-400 text-right">
                    ※棄権枠はチーム選択で「シード/棄権」を選択
                </div>
                <button id="reset-btn" class="reset-btn" title="トーナメントをリセット">
                    <span class="material-symbols-rounded">restart_alt</span>
                </button>
            </div>
        </div>

        <div class="bracket-container">
            <div id="bracket-wrapper" class="bracket-wrapper">
                <div class="flex items-center justify-center w-full h-32 text-gray-400 font-bold">
                    Loading tournament data...
                </div>
            </div>
        </div>
    </main>

    <div id="confirm-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-title">確認</div>
            <div id="modal-message" class="modal-body">メッセージ</div>
            <div class="modal-actions">
                <button id="modal-cancel-btn" class="btn-modal btn-cancel">キャンセル</button>
                <button id="modal-confirm-btn" class="btn-modal btn-confirm">OK</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
        import { getFirestore, doc, onSnapshot, setDoc } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAotBKDxazOEtOv_IzoqW9bNPQXaz7a3vA",
            authDomain: "daigakuhai-support-fb.firebaseapp.com",
            projectId: "daigakuhai-support-fb",
            storageBucket: "daigakuhai-support-fb.firebasestorage.app",
            messagingSenderId: "939931798179",
            appId: "1:939931798179:web:8320fba89104e81f47cd16"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const tournamentRef = doc(db, "state", "tournament");
        const matchRef = doc(db, "state", "match");
        const settingsRef = doc(db, "state", "settings");

        let teamsData = [];
        let currentFormat = 8;
        let tournamentData = {
            format: 8,
            matches: {},
            roundNames: {}
        };
        let tournamentSettings = {
            matchFormat: { other: 'BO3', semis: 'BO5', finals: 'BO5' }
        };

        let isUpdating = false;
        let currentUser = { name: '', role: '' };
        let isReadOnly = false;

        const SEED_ID = "THE_SEED";

        const bracketWrapper = document.getElementById('bracket-wrapper');
        const formatSelect = document.getElementById('format-select');
        const resetBtn = document.getElementById('reset-btn');
        const confirmModal = document.getElementById('confirm-modal');
        const modalMessage = document.getElementById('modal-message');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');

        let onConfirmAction = null;
        let onCancelAction = null;

        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'settings-update') {
                currentUser = event.data.user;
                applyRoleRestrictions();
            }
        });

        function applyRoleRestrictions() {
            const role = currentUser.role;
            if (role === '実況' || role === '解説') {
                isReadOnly = true;
                document.body.classList.add('read-only-mode');
                formatSelect.disabled = true;
                resetBtn.style.display = 'none';
            } else {
                isReadOnly = false;
                document.body.classList.remove('read-only-mode');
                formatSelect.disabled = false;
                resetBtn.style.display = 'flex';
            }
            renderBracket();
        }

        async function init() {
            await fetchTeams();
            setupEventHandlers();
            setupFirestoreListener();
            setupDragScroll();
        }

        async function fetchTeams() {
            try {
                const res = await fetch('../json/teams.json');
                const data = await res.json();
                teamsData = data.map(t => ({ id: t.id, name: t.teamName }));
                if (!teamsData.some(t => t.id === SEED_ID)) {
                    teamsData.unshift({ id: SEED_ID, name: "シード/棄権" }); 
                }
            } catch (e) {
                console.error("Fetch error", e);
            }
        }

        function setupEventHandlers() {
            formatSelect.addEventListener('change', (e) => {
                if (isReadOnly) return;
                const newFormat = parseInt(e.target.value);
                if (newFormat === currentFormat) return;
                showModal("トーナメント規模の変更", "現在の入力内容はリセットされます。変更しますか？",
                    () => { setTeamCount(newFormat); },
                    () => { formatSelect.value = currentFormat; }
                );
            });

            resetBtn.addEventListener('click', () => {
                if (isReadOnly) return;
                showModal("リセット確認", "すべての対戦結果と配信設定を初期化しますか？", () => { resetTournament(); });
            });

            modalConfirmBtn.onclick = () => { if (onConfirmAction) onConfirmAction(); closeModal(); };
            modalCancelBtn.onclick = () => { if (onCancelAction) onCancelAction(); closeModal(); };
        }

        function setupDragScroll() {
            const slider = document.querySelector('.bracket-container');
            let isDown = false;
            let startX, scrollLeft, startY, scrollTop;

            slider.addEventListener('mousedown', (e) => {
                if (['SELECT', 'BUTTON', 'INPUT'].includes(e.target.tagName)) return;
                isDown = true;
                slider.classList.add('active');
                startX = e.pageX - slider.offsetLeft;
                scrollLeft = slider.scrollLeft;
                startY = e.pageY - slider.offsetTop;
                scrollTop = slider.scrollTop;
            });
            slider.addEventListener('mouseleave', () => { isDown = false; slider.classList.remove('active'); });
            slider.addEventListener('mouseup', () => { isDown = false; slider.classList.remove('active'); });
            slider.addEventListener('mousemove', (e) => {
                if (!isDown) return;
                e.preventDefault();
                const x = e.pageX - slider.offsetLeft;
                const y = e.pageY - slider.offsetTop;
                slider.scrollLeft = scrollLeft - (x - startX);
                slider.scrollTop = scrollTop - (y - startY);
            });
        }

        function showModal(title, message, onOk = null, onCancel = null) {
            document.querySelector('.modal-title').textContent = title;
            modalMessage.textContent = message;
            onConfirmAction = onOk;
            onCancelAction = onCancel;
            modalCancelBtn.style.display = onCancel ? 'block' : (onOk ? 'block' : 'none');
            
            if (title.includes("リセット") || title.includes("変更")) {
                modalConfirmBtn.classList.add('btn-danger');
                modalConfirmBtn.classList.remove('btn-confirm');
            } else {
                modalConfirmBtn.classList.add('btn-confirm');
                modalConfirmBtn.classList.remove('btn-danger');
            }

            if(!onOk && !onCancel) {
                modalConfirmBtn.textContent = "閉じる";
                modalCancelBtn.style.display = 'none';
            } else {
                modalConfirmBtn.textContent = "OK";
                modalCancelBtn.style.display = 'block';
            }
            confirmModal.classList.add('show');
        }

        function closeModal() {
            confirmModal.classList.remove('show');
            onConfirmAction = null;
            onCancelAction = null;
        }

        // --- Firestore ---
        function setupFirestoreListener() {
            onSnapshot(tournamentRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    if (!isUpdating) {
                        tournamentData = data;
                        if (!tournamentData.matches) tournamentData.matches = {};
                        if (!tournamentData.roundNames) tournamentData.roundNames = {};
                        if (tournamentData.format) {
                            currentFormat = parseInt(tournamentData.format);
                            formatSelect.value = currentFormat;
                        }
                        
                        if (propagateBracketData()) {
                            saveTournamentData();
                        } else {
                            renderBracket();
                        }
                    }
                } else {
                    saveTournamentData();
                }
            });

            // 対戦設定の監視 (スコア等の自動同期)
            onSnapshot(matchRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    if (data.tournamentMatchId && tournamentData.matches[data.tournamentMatchId]) {
                        handleMatchUpdate(data.tournamentMatchId, data);
                    }
                }
            });

            // 大会設定の監視
            onSnapshot(settingsRef, (docSnap) => {
                if (docSnap.exists()) {
                    tournamentSettings = docSnap.data();
                    renderBracket(); // 設定反映のために再描画
                }
            });
        }

        function handleMatchUpdate(matchId, matchData) {
            const match = tournamentData.matches[matchId];
            if (!match) return;

            let alphaWins = 0;
            let bravoWins = 0;
            if (matchData.games && Array.isArray(matchData.games)) {
                matchData.games.forEach(g => {
                    if (g.winner === 'alpha') alphaWins++;
                    if (g.winner === 'bravo') bravoWins++;
                });
            }

            let needsUpdate = false;
            
            if (match.scoreA !== alphaWins) { match.scoreA = alphaWins; needsUpdate = true; }
            if (match.scoreB !== bravoWins) { match.scoreB = bravoWins; needsUpdate = true; }

            const boType = matchData.boType || 'BO3';
            const winThreshold = boType === 'BO5' ? 3 : 2;
            
            let newWinner = null;
            if (alphaWins >= winThreshold) newWinner = 'alpha';
            else if (bravoWins >= winThreshold) newWinner = 'bravo';
            
            if (match.winner !== newWinner) {
                match.winner = newWinner;
                needsUpdate = true;
            }

            if (needsUpdate) {
                renderBracket();
                saveTournamentData(); 
            }
        }

        async function saveTournamentData() {
            if (isReadOnly) return; 
            isUpdating = true;
            tournamentData.format = currentFormat;
            try { await setDoc(tournamentRef, tournamentData, { merge: true }); }
            catch (e) { console.error("保存エラー", e); }
            finally { isUpdating = false; }
        }

        function setTeamCount(count) {
            if (isReadOnly) return;
            currentFormat = count;
            tournamentData.matches = {}; 
            tournamentData.roundNames = {};
            tournamentData.format = count;
            renderBracket();
            saveTournamentData();
        }

        function resetTournament() {
            if (isReadOnly) return;
            tournamentData.matches = {}; 
            renderBracket();
            saveTournamentData();
        }

        // --- Core Logic: Propagate Winners ---
        function propagateBracketData() {
            let hasChanges = false;
            const totalRounds = Math.log2(currentFormat);

            for (let r = 2; r <= totalRounds; r++) {
                const matchCount = currentFormat / Math.pow(2, r);
                for (let m = 1; m <= matchCount; m++) {
                    const matchId = `r${r}_m${m}`;
                    if (!tournamentData.matches[matchId]) tournamentData.matches[matchId] = { alpha: null, bravo: null, scoreA: 0, scoreB: 0, winner: null, isLive: false };
                    
                    const match = tournamentData.matches[matchId];
                    
                    const prevMatchA_Id = `r${r-1}_m${(m*2)-1}`;
                    const prevMatchB_Id = `r${r-1}_m${(m*2)}`;
                    const prevMatchA = tournamentData.matches[prevMatchA_Id];
                    const prevMatchB = tournamentData.matches[prevMatchB_Id];

                    const winnerA = getWinnerTeamId(prevMatchA);
                    const winnerB = getWinnerTeamId(prevMatchB);

                    if (match.alpha !== (winnerA || null)) {
                        match.alpha = (winnerA || null);
                        hasChanges = true;
                        if(match.isLive) syncToMatchSettings(matchId, r);
                    }

                    if (match.bravo !== (winnerB || null)) {
                        match.bravo = (winnerB || null);
                        hasChanges = true;
                        if(match.isLive) syncToMatchSettings(matchId, r);
                    }
                    
                    if (checkAutoWin(matchId, match)) {
                        hasChanges = true;
                    }
                }
            }
            return hasChanges;
        }

        function checkAutoWin(matchId, match) {
            let changed = false;
            const isAlphaSeed = match.alpha === SEED_ID;
            const isBravoSeed = match.bravo === SEED_ID;
            if (isAlphaSeed && isBravoSeed) {
                if (match.winner !== null) { match.winner = null; changed = true; }
            } else if (isAlphaSeed) {
                if (match.winner !== 'bravo' || match.scoreA !== 0) {
                    match.winner = 'bravo'; match.scoreA = 0; changed = true;
                }
            } else if (isBravoSeed) {
                if (match.winner !== 'alpha' || match.scoreB !== 0) {
                    match.winner = 'alpha'; match.scoreB = 0; changed = true;
                }
            }
            return changed;
        }

        function syncToMatchSettings(matchId, roundNum) {
            const match = tournamentData.matches[matchId];
            if (!match || !match.alpha || !match.bravo) return;
            if (match.alpha === SEED_ID || match.bravo === SEED_ID) return;

            let rName = tournamentData.roundNames && tournamentData.roundNames[roundNum] ? tournamentData.roundNames[roundNum] : null;
            const totalRounds = Math.log2(currentFormat);
            
            if (!rName) {
                if (roundNum === totalRounds) rName = "決勝";
                else if (roundNum === totalRounds - 1) rName = "準決勝";
                else if (roundNum === totalRounds - 2 && totalRounds > 2) rName = "準々決勝";
                else rName = `ラウンド ${roundNum}`;
            }

            const boType = getRoundFormat(roundNum, totalRounds);
            const gameCount = boType === 'BO5' ? 5 : 3;
            const games = Array(gameCount).fill({ stage: "未決定", winner: "none" });

            const syncData = {
                alphaTeamId: match.alpha,
                bravoTeamId: match.bravo,
                roundName: rName,
                games: games,
                boType: boType,
                tournamentMatchId: matchId
            };
            setDoc(matchRef, syncData, { merge: true }).catch(e => console.error("Sync error:", e));
        }

        function getRoundFormat(roundNum, totalRounds) {
            const settings = tournamentSettings.matchFormat || { other: 'BO3', semis: 'BO5', finals: 'BO5' };
            if (roundNum === totalRounds) return settings.finals;
            if (roundNum === totalRounds - 1) return settings.semis;
            return settings.other;
        }

        function getWinnerTeamId(match) {
            if (!match || !match.winner) return null;
            return match.winner === 'alpha' ? match.alpha : match.bravo;
        }

        function getTeamName(id) {
            if (!id) return "未決定";
            const t = teamsData.find(t => t.id === id);
            return t ? t.name : "不明なチーム";
        }

        // --- UI Functions ---

        window.updateRoundName = (roundNum, newName) => {
            if(isReadOnly) return;
            if (!tournamentData.roundNames) tournamentData.roundNames = {};
            tournamentData.roundNames[roundNum] = newName;
            saveTournamentData();
        };

        window.toggleLiveStatus = (targetMatchId, roundNum) => {
            if(isReadOnly) return;
            
            if(!tournamentData.matches[targetMatchId]) tournamentData.matches[targetMatchId] = { alpha: null, bravo: null, scoreA: 0, scoreB: 0, winner: null, isLive: false };
            
            const targetMatch = tournamentData.matches[targetMatchId];
            const newState = !targetMatch.isLive;
            
            targetMatch.isLive = newState;
            
            if (newState) {
                const hasTeams = !!targetMatch.alpha && !!targetMatch.bravo;
                const isFinished = !!targetMatch.winner;
                if(hasTeams && !isFinished) {
                    syncToMatchSettings(targetMatchId, roundNum);
                }
            }
            
            updateMatchData({}, null);
        };

        window.updateTeam = (matchId, side, teamId) => {
            if(isReadOnly) return;
            updateMatchData(matchId, { [side]: teamId });
        };

        window.updateScore = (matchId, side, score) => {
            if(isReadOnly) return;
            
            const match = tournamentData.matches[matchId] || { scoreA: 0, scoreB: 0 };
            const newScoreA = side === 'alpha' ? parseInt(score) : (match.scoreA || 0);
            const newScoreB = side === 'bravo' ? parseInt(score) : (match.scoreB || 0);

            const roundNum = parseInt(matchId.split('_')[0].replace('r', ''));
            const totalRounds = Math.log2(currentFormat);
            const boType = getRoundFormat(roundNum, totalRounds);
            const threshold = boType === 'BO5' ? 3 : 2;

            let newWinner = null;
            if (newScoreA >= threshold) newWinner = 'alpha';
            else if (newScoreB >= threshold) newWinner = 'bravo';

            const updates = {
                scoreA: newScoreA,
                scoreB: newScoreB,
                winner: newWinner
            };
            
            updateMatchData(matchId, updates);
        };

        function updateMatchData(matchId, updates) {
            if (matchId && updates) {
                if (!tournamentData.matches[matchId]) tournamentData.matches[matchId] = {};
                for (const key in updates) {
                    tournamentData.matches[matchId][key] = updates[key];
                }
            }

            propagateBracketData();
            renderBracket();
            saveTournamentData();
        }

        // --- Rendering ---
        function renderBracket() {
            bracketWrapper.innerHTML = '';
            const totalRounds = Math.log2(currentFormat);
            
            for (let r = 1; r <= totalRounds; r++) {
                const roundCol = document.createElement('div');
                roundCol.className = 'round-column';
                
                const header = document.createElement('div');
                header.className = 'round-header';
                let defaultName = `ラウンド ${r}`;
                if (r === totalRounds) defaultName = "決勝";
                else if (r === totalRounds - 1) defaultName = "準決勝";
                else if (r === totalRounds - 2 && totalRounds > 2) defaultName = "準々決勝";

                const savedName = tournamentData.roundNames && tournamentData.roundNames[r] ? tournamentData.roundNames[r] : defaultName;
                const titleInput = document.createElement('input');
                titleInput.type = 'text';
                titleInput.className = 'round-name-input';
                titleInput.value = savedName;
                titleInput.onchange = (e) => updateRoundName(r, e.target.value);
                header.appendChild(titleInput);
                roundCol.appendChild(header);

                const matchCount = currentFormat / Math.pow(2, r);
                const boType = getRoundFormat(r, totalRounds);

                for (let m = 1; m <= matchCount; m++) {
                    const matchId = `r${r}_m${m}`;
                    if(!tournamentData.matches[matchId]) tournamentData.matches[matchId] = { alpha: null, bravo: null, scoreA: 0, scoreB: 0, winner: null, isLive: false };
                    
                    const matchData = tournamentData.matches[matchId];
                    const alphaName = getTeamName(matchData.alpha);
                    const bravoName = getTeamName(matchData.bravo);
                    
                    const hasTeams = !!matchData.alpha && !!matchData.bravo;
                    const isFinished = !!matchData.winner;
                    const isActiveContext = hasTeams && !isFinished;

                    const card = createMatchCard(matchId, r, matchData, r === 1, alphaName, bravoName, isActiveContext, boType);
                    roundCol.appendChild(card);
                }
                bracketWrapper.appendChild(roundCol);
            }
        }

        function createMatchCard(matchId, roundNum, data, isFirstRound, alphaName, bravoName, isActiveContext, boType) {
            const div = document.createElement('div');
            const statusClass = isActiveContext ? 'status-active' : 'status-inactive';
            div.className = `match-card ${data.isLive ? `is-live ${statusClass}` : ''}`;
            
            const header = document.createElement('div');
            header.className = 'match-header';
            
            const headerLeft = document.createElement('div');
            headerLeft.className = 'header-left-group';

            const idBadge = document.createElement('span');
            idBadge.className = 'match-id';
            idBadge.textContent = matchId.toUpperCase().replace('_', '-');
            
            const boBadge = document.createElement('span');
            boBadge.className = 'bo-badge';
            boBadge.textContent = boType;

            headerLeft.appendChild(idBadge);
            headerLeft.appendChild(boBadge);

            const liveControl = document.createElement('div');
            liveControl.className = 'live-control';
            const liveBtn = document.createElement('button');
            liveBtn.className = 'live-btn';
            liveBtn.onclick = () => toggleLiveStatus(matchId, roundNum);
            liveBtn.innerHTML = `<span class="material-symbols-rounded" style="font-size: 14px;">sensors</span>${data.isLive ? 'ON AIR' : '配信'}`;
            
            liveControl.appendChild(liveBtn);
            header.appendChild(headerLeft);
            header.appendChild(liveControl);
            div.appendChild(header);

            div.appendChild(createTeamRow(matchId, 'alpha', data, isFirstRound, alphaName, boType));
            div.appendChild(createTeamRow(matchId, 'bravo', data, isFirstRound, bravoName, boType));

            return div;
        }

        function createTeamRow(matchId, side, data, isFirstRound, nameDisplay, boType) {
            const row = document.createElement('div');
            const isWinner = data.winner === side;
            const isLoser = data.winner && data.winner !== side;
            const disabledAttr = isReadOnly ? 'disabled' : '';
            row.className = `team-row ${isWinner ? 'winner' : (isLoser ? 'loser' : '')}`;
            
            const labelClass = side === 'alpha' ? 'label-alpha' : 'label-bravo';
            const score = side === 'alpha' ? data.scoreA : data.scoreB;
            const teamId = side === 'alpha' ? data.alpha : data.bravo;

            let contentHTML = `<div class="team-label ${labelClass}"></div>`;
            contentHTML += `<div class="team-info-area">`;
            if (isFirstRound) {
                contentHTML += getTeamSelectHTML(matchId, side, teamId, disabledAttr);
            } else {
                const undecidedClass = nameDisplay === "未決定" ? "text-undecided" : "";
                contentHTML += `<div class="team-name-display ${undecidedClass}" title="${nameDisplay}">${nameDisplay}</div>`;
            }
            contentHTML += `</div>`;

            contentHTML += `<div class="action-area">`;
            contentHTML += `
                <select class="score-select" onchange="updateScore('${matchId}', '${side}', this.value)" ${disabledAttr}>
                    ${getScoreOptions(score, boType)}
                </select>
                <div class="win-badge ${isWinner ? 'active' : ''}" title="${isWinner ? 'WINNER' : ''}">
                    <span class="material-symbols-rounded text-base">emoji_events</span>
                </div>
            `;
            contentHTML += `</div>`;
            row.innerHTML = contentHTML;
            return row;
        }

        function getTeamSelectHTML(matchId, side, currentId, disabledAttr) {
            let html = `<select class="team-select" onchange="updateTeam('${matchId}', '${side}', this.value)" ${disabledAttr}>`;
            html += `<option value="">選択...</option>`;
            teamsData.forEach(t => {
                const selected = t.id === currentId ? 'selected' : '';
                html += `<option value="${t.id}" ${selected}>${t.name}</option>`;
            });
            html += `</select>`;
            return html;
        }

        function getScoreOptions(currentScore, boType) {
            let html = '';
            const maxScore = boType === 'BO5' ? 3 : 2;
            for(let i=0; i<=maxScore; i++) {
                html += `<option value="${i}" ${parseInt(currentScore) === i ? 'selected' : ''}>${i}</option>`;
            }
            return html;
        }

        init();
    </script>
</body>
</html>